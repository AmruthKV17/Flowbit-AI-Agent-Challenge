import { processInvoice } from './engine/engine';
import { pool } from './db';

// ANSI Color Codes
const RESET = '\x1b[0m';
const GREEN = '\x1b[32m';
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const CYAN = '\x1b[36m';
const MAGENTA = '\x1b[35m';
const BOLD = '\x1b[1m';

interface DemoStats {
  invoiceId: string;
  vendor: string;
  confidence: number;
  autoCorrectedFields: number;
  humanReview: boolean;
  status: string;
  phase: 'Learning' | 'Application';
}

async function main() {
  // Phase 1: Initial Invoices (The System "Learns" from these via human corrections in DB)
  const learningPhaseIds = [
    'INV-A-001', 
    'INV-A-003', 
    'INV-B-001', 
    'INV-B-003', 
    'INV-C-001', 
    'INV-C-002'
  ];

  // Phase 2: Later Invoices (The System "Applies" learned memory here)
  const applicationPhaseIds = [
    'INV-A-002', // Supplier GmbH: should benefit from learned serviceDate & PO logic
    'INV-A-004', // Supplier GmbH: duplicate + learned patterns
    'INV-B-002', // Parts AG: VAT pattern reused
    'INV-B-004', // Parts AG: duplicate handling
    'INV-C-003', // Freight & Co: known freight patterns -> fewer flags
    'INV-C-004'  // Freight & Co: similar behavior
  ];

  const stats: DemoStats[] = [];

  console.log(`${BOLD}${CYAN}ðŸš€ Starting Intelligent Invoice Processing Demo...${RESET}\n`);

  // --- PROCESSING PHASE 1 ---
  console.log(`${BOLD}${MAGENTA}--- PHASE 1: Processing Initial Invoices (Learning) ---${RESET}`);
  for (const id of learningPhaseIds) {
    await processAndTrack(id, 'Learning', stats);
  }

  console.log(`\n${BOLD}${MAGENTA}--- PHASE 2: Processing Later Invoices (Application) ---${RESET}`);
  // --- PROCESSING PHASE 2 ---
  for (const id of applicationPhaseIds) {
    await processAndTrack(id, 'Application', stats);
  }

  // --- SUMMARY TABLE ---
  console.log(`\n${BOLD}${CYAN}ðŸ“Š Executive Summary & Learning Impact${RESET}`);
  console.table(stats.map(s => ({
    Phase: s.phase,
    ID: s.invoiceId,
    Vendor: s.vendor,
    Conf: s.confidence.toFixed(2),
    'Auto-Fixes': s.autoCorrectedFields,
    Status: s.status
  })));

  const totalAuto = stats.filter(s => s.status === 'APPROVED').length;
  const learningAuto = stats.filter(s => s.phase === 'Learning' && s.status === 'APPROVED').length;
  const appAuto = stats.filter(s => s.phase === 'Application' && s.status === 'APPROVED').length;

  console.log(`\n${BOLD}ðŸ“ˆ Learning Effectiveness Metrics:${RESET}`);
  console.log(`   Phase 1 (Learning) Auto-Approval Rate:    ${((learningAuto / learningPhaseIds.length) * 100).toFixed(0)}%`);
  console.log(`   Phase 2 (Application) Auto-Approval Rate: ${((appAuto / applicationPhaseIds.length) * 100).toFixed(0)}%`);
  
  if (appAuto > learningAuto) {
    console.log(`   ${GREEN}âœ… SUCCESS: System demonstrated learning improvement!${RESET}`);
  } else {
    console.log(`   ${YELLOW}âš ï¸  NOTE: Learning impact neutral or requires more data.${RESET}`);
  }

  await pool.end();
}

async function processAndTrack(id: string, phase: 'Learning' | 'Application', stats: DemoStats[]) {
  process.stdout.write(`Processing ${id} ... `);
  const output = await processInvoice(id);

  if (!output) {
    console.log(`${RED}Not Found${RESET}`);
    return;
  }

  console.log(output);
  

  const isHighConfidence = output.confidenceScore >= 0.9;
  const status = isHighConfidence ? `${GREEN}AUTO-APPROVED${RESET}` : `${RED}NEEDS REVIEW${RESET}`;
  
  // Count auto-corrections (generated by memory)
  const autoCorrectionCount = output.auditTrail.filter(a => a.details.startsWith('Auto-corrected')).length;

  console.log(status);
  
  // Detailed Log (concise)
  if (autoCorrectionCount > 0) {
    console.log(`   ${YELLOW}âš¡ Auto-corrected ${autoCorrectionCount} field(s)${RESET}`); // concise
  }
  if (output.requiresHumanReview) {
    // console.log(`   ${YELLOW}âš ï¸  Reason: ${output.reasoning}${RESET}`); // keeping it cleaner for long list
  }
  // console.log(`   Confidence: ${output.confidenceScore.toFixed(2)}`);

  stats.push({
    invoiceId: id,
    vendor: output.normalizedInvoice.vendor || 'Unknown',
    confidence: output.confidenceScore,
    autoCorrectedFields: autoCorrectionCount,
    humanReview: output.requiresHumanReview,
    status: isHighConfidence ? 'APPROVED' : 'REVIEW',
    phase
  });
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
